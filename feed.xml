<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://www.nicholastolhurst.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://www.nicholastolhurst.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-03-17T21:02:55+00:00</updated><id>https://www.nicholastolhurst.com/feed.xml</id><title type="html">blank</title><subtitle>A simple tech blog.</subtitle><entry><title type="html">day 1 of a week of clojure as a total beginner</title><link href="https://www.nicholastolhurst.com/blog/2023/1-week-of-clojure-1/" rel="alternate" type="text/html" title="day 1 of a week of clojure as a total beginner"/><published>2023-03-17T00:00:00+00:00</published><updated>2023-03-17T00:00:00+00:00</updated><id>https://www.nicholastolhurst.com/blog/2023/1-week-of-clojure-1</id><content type="html" xml:base="https://www.nicholastolhurst.com/blog/2023/1-week-of-clojure-1/"><![CDATA[<h3 id="context">Context</h3> <ul> <li>I have never used <strong>clojure</strong> before.</li> <li>I will commit at least 1 hour per day to learning.</li> <li>I will keep a log of how much time I am spending.</li> <li>I will be honest about my approach and thoughts.</li> <li>I have experience with various OOP languages, but not in a professional capacity.</li> <li>I work as an infrastructure engineer, I am not new to tech.</li> </ul> <h3 id="setup">Setup</h3> <p>Where to start?</p> <ol> <li><strong>Google “how to install closure”</strong></li> <li><strong>Click on “Show instead ‘how to install clojure’“</strong></li> </ol> <p>After poking around the many different ways to get <strong>clojure</strong> installed - and some failed attempts with WSL2 🥴 - I found that vscode has an extension/environment - <a href="https://calva.io/">Calva</a>.</p> <p>This was a no-brainer. Though I am also interested in learning <a href="https://www.gnu.org/software/emacs/">Emacs</a>, <a href="https://www.vim.org/">Vim</a>, and the numerous other editors out there (and I will, I promise), I am already familiar with <a href="https://code.visualstudio.com/">vscode</a>, and I’m here to give <strong>clojure</strong> my best effort and full attention.</p> <p>Installing Calva is easy. Below is the one-liner, or you could use the UI.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">code <span class="nt">--install-extension</span>  betterthantomorrow.calva</code></pre></figure> <p>It is also admirably beginner friendly, with an interactive getting-started guide that has a witty style. To start this, press<code class="language-plaintext highlighter-rouge">ctrl</code>+<code class="language-plaintext highlighter-rouge">shift</code>+<code class="language-plaintext highlighter-rouge">p</code>, type <code class="language-plaintext highlighter-rouge">calfig</code>, press <code class="language-plaintext highlighter-rouge">enter</code> (you will learn more about these tasks in the guide!).</p> <p>Wow. This looks nerdy 🤓. I’ll wait to get stuck in; first, some reading:</p> <ul> <li><a href="https://clojure.org/guides/getting_started">https://clojure.org/guides/getting_started</a></li> <li><a href="https://clojure.org/guides/structural_editing">https://clojure.org/guides/structural_editing</a></li> <li><a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a></li> </ul> <p>Okay, I wish I didn’t read them - even though I know it is essential, it made little sense at this point 🤷‍♂️. It took a lot to follow, especially for a newbie in this type of programming. In retrospect - <em>this blog was written up a day later</em> - I should have completed the getting-started guide first. A little warm-up is advised.</p> <h3 id="actually-getting-started">Actually getting started</h3> <p>Ah, this is better.</p> <p>My initial thoughts are this is <del>beginner</del> friendly 🙌. Can programming languages be inclusive for newbies? 🤔 I already feel like I am being lured in and want to learn more. As I spend the next ~40 minutes working my way through the introduction.</p> <p>There are lots of shortcuts worth learning. Below 👇 are the top 4 that I most use so far. I’ll continue to post these as I discover them.</p> <ul> <li><code class="language-plaintext highlighter-rouge">alt</code>+<code class="language-plaintext highlighter-rouge">enter</code>: evaluate top level form.</li> <li><code class="language-plaintext highlighter-rouge">ctrl</code>+<code class="language-plaintext highlighter-rouge">enter</code>: evaluate current form.</li> <li><code class="language-plaintext highlighter-rouge">ctrl</code>+<code class="language-plaintext highlighter-rouge">alt</code>+<code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">enter</code>: load / reload current file.</li> <li><code class="language-plaintext highlighter-rouge">escape</code>: remove all evaluated results.</li> </ul> <h3 id="wrap-up">Wrap up</h3> <p>The introductory journey is longer than I thought. It’s been a very late hour. I’m still here and even more invested. Have I learned anything? Only that I understand less. I have no idea what this would ever be used for - but that’s okay. Trust the process.</p> <p>Let me know your thoughts and recommendations! Apologies if I mistype or misunderstand. I am always open to feedback and corrections.</p> <p>I’ll check back in tomorrow, thanks for reading 🙏</p>]]></content><author><name></name></author><category term="clojure-7-days"/><category term="clojure"/><category term="learning"/><category term="technology"/><category term="beginner"/><category term="journey"/><summary type="html"><![CDATA[Step 1: Google "how to install closure". Step 2: Click on "Show instead 'how to install clojure'"]]></summary></entry><entry><title type="html">node dependency caching</title><link href="https://www.nicholastolhurst.com/blog/2023/faster-ci-node-caching/" rel="alternate" type="text/html" title="node dependency caching"/><published>2023-03-13T00:00:00+00:00</published><updated>2023-03-13T00:00:00+00:00</updated><id>https://www.nicholastolhurst.com/blog/2023/faster-ci-node-caching</id><content type="html" xml:base="https://www.nicholastolhurst.com/blog/2023/faster-ci-node-caching/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/npm-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/npm-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/npm-1400.webp"/> <img src="/assets/img/npm.png" class="img-fluid no-border hero rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="what-is-caching">What is caching?</h3> <p>In short, caching is a transient high-speed data storage layer that stores data for faster retrieval than from the source.</p> <p>For #AzureDevOps, this enables us to store our project’s dependencies on the pipeline’s cache layer and then retrieve them on subsequent runs. This additional task can make subsequent runs much faster.</p> <p>In some cases, caching may not be economical, as the retrieval from a cache may take longer than downloading from the origin.</p> <h3 id="how-to-use-the-cache2-task">How to use the <code class="language-plaintext highlighter-rouge">Cache@2</code> task?</h3> <p>The most basic implementation of <code class="language-plaintext highlighter-rouge">Cache@2</code> requires a <code class="language-plaintext highlighter-rouge">cache key</code> and a <code class="language-plaintext highlighter-rouge">path</code>. The <code class="language-plaintext highlighter-rouge">key</code> is used to generate a dynamic hash that determines whether or not there is a valid cache stored. The <code class="language-plaintext highlighter-rouge">path</code> is the directory you want to store and retrieve.</p> <p>The cache key consists of strings, file paths, or file patterns separated by a pipe character (<code class="language-plaintext highlighter-rouge">|</code>).</p> <p>Use strings as identifiers, a good example would be a tool name, tool version, or OS version. Think, “if I change my OS version, do my dependencies change?”. If so, having the OS version referenced in the cache key is correct.</p> <p>A file path (file pattern) produces a hash based on the file (collection of files), resulting in a unique key each time the contents of this file (these files) change. Think, “What changes only when I update my dependencies?”. Use that file as a part of the cache key.</p> <p>For example, we will look at the pipeline’s NPM dependencies. In the pipeline, we require a specific Node version. This node version matches the installed tools of our developers. In this case, we are not concerned with the version of the tool. We will start our key with simply the tool <code class="language-plaintext highlighter-rouge">node</code>. Though not an immediate requirement, we likely want to build the application on Windows and Linux operating systems. Therefore, the cache key can extend to <code class="language-plaintext highlighter-rouge">node | "$(Agent.Os)"</code>. Finally, to determine whether or not the dependencies have changed, we will target a single <code class="language-plaintext highlighter-rouge">package-lock.json</code> file. We know the <code class="language-plaintext highlighter-rouge">package-lock.json</code> only updates when a Node dependency has changed. Our final cache key is <code class="language-plaintext highlighter-rouge">node | "$(Agent.OS)" | **/package-lock.json</code>.</p> <blockquote> <p>Gotcha: Keys with a period (<code class="language-plaintext highlighter-rouge">.</code>) in them are considered file paths. To avoid this interpretation, wrap those keys in double quotes (<code class="language-plaintext highlighter-rouge">"</code>), as we have the <code class="language-plaintext highlighter-rouge">"$(Agent.OS)"</code> segment in the example.</p> </blockquote> <p>The <code class="language-plaintext highlighter-rouge">path</code> parameter value is the location of the Node dependencies. In our case, this is <code class="language-plaintext highlighter-rouge">$(Build.SourcesDirectory)\node_modules</code>.</p> <p>Having <code class="language-plaintext highlighter-rouge">node_modules</code> pull from the cache is considerably quicker than downloading them using <code class="language-plaintext highlighter-rouge">npm</code>. Moreover, installing <code class="language-plaintext highlighter-rouge">node_modules</code> when they already exist is quicker than installing them into an empty directory. However, do we need to install them if we have retrieved them from the cache?</p> <p>By setting the task parameter <code class="language-plaintext highlighter-rouge">cacheHitVar</code>, a build-scoped variable is available to us and can be used as a condition in subsequent tasks, allowing us to avoid the unnecessary re-install of <code class="language-plaintext highlighter-rouge">node_modules</code> if they already exist on disk. Therefore, we will set <code class="language-plaintext highlighter-rouge">cacheHitVar</code> to <code class="language-plaintext highlighter-rouge">NODE_CACHE_HIT</code> and add the condition <code class="language-plaintext highlighter-rouge">ne(variables.NODE_CACHE_HIT, 'true')</code> to the step that installs our dependencies.</p> <h4 id="example">Example</h4> <figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">Cache@2</span>
  <span class="na">displayName</span><span class="pi">:</span> <span class="s">Cache node_modules Directory</span>
  <span class="na">inputs</span><span class="pi">:</span>
    <span class="na">key</span><span class="pi">:</span> <span class="s1">'</span><span class="s">npm</span><span class="nv"> </span><span class="s">|</span><span class="nv"> </span><span class="s">"$(Agent.OS)"</span><span class="nv"> </span><span class="s">|</span><span class="nv"> </span><span class="s">$(Build.SourcesDirectory)\package-lock.json'</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">$(Build.SourcesDirectory)\node_modules</span>
    <span class="na">cacheHitVar</span><span class="pi">:</span> <span class="s">NODE_CACHE_HIT</span>

<span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">Npm@1</span>
  <span class="na">displayName</span><span class="pi">:</span> <span class="s">Install node_modules</span>
  <span class="na">inputs</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">install'</span>
    <span class="na">workingDir</span><span class="pi">:</span> <span class="s">$(Build.SourcesDirectory)</span>
  <span class="na">condition</span><span class="pi">:</span> <span class="s">ne(variables.NODE_CACHE_HIT, 'true')</span></code></pre></figure> <p>What took approximately 2 minutes and 40 seconds now takes 35 seconds on each subsequent run after a dependency change. In this example, we can apply this to 2 different Node applications, saving 3 minutes and 40 seconds.</p> <p>There we have it! Our Node dependencies are cached, and a considerable saving from merely a few extra lines of code.</p> <p>What could be next? Caching NuGet packages?</p>]]></content><author><name></name></author><category term="azure-devops"/><category term="Azure"/><category term="DevOps"/><category term="Pipelines"/><category term="CICD"/><summary type="html"><![CDATA[Cache Node.JS dependencies between pipeline runs.]]></summary></entry><entry><title type="html">an introduction to faster cicd</title><link href="https://www.nicholastolhurst.com/blog/2023/faster-ci-introduction/" rel="alternate" type="text/html" title="an introduction to faster cicd"/><published>2023-03-11T00:00:00+00:00</published><updated>2023-03-11T00:00:00+00:00</updated><id>https://www.nicholastolhurst.com/blog/2023/faster-ci-introduction</id><content type="html" xml:base="https://www.nicholastolhurst.com/blog/2023/faster-ci-introduction/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/ci-cd-logo-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/ci-cd-logo-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/ci-cd-logo-1400.webp"/> <img src="/assets/img/ci-cd-logo.png" class="img-fluid no-border hero rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="why">Why?</h3> <p>Nowadays, software development relies heavily on CI / CD pipelines to build, test, package and deploy your products. The productivity of your development team directly depends on the speed of your CI / CD pipelines. With that in mind, it’s clear how important it is to periodically benchmark and invest in CI / CD improvements.</p> <p>But how much effort should we invest?</p> <p>Optimising CI / CD for performance eventually comes with diminishing returns. The amount of time and effort investigating, benchmarking, proving and discarding will ultimately become economically impractical. Fortunately, I am not concerned with the ROI of my efforts in this blog series. In this blog series, I’m here to waste my own time in an effort to produce the most gains.</p> <p>I will share the output of my journey here, hoping it will help others optimise their pipelines with fewer mistakes and headaches than I experience.</p> <h3 id="first-some-context">First, some context</h3> <p>I frequently work with a large monolithic code base. Over 50 developers are working on this repository. There are hundreds of projects that each require building, testing, packaging, and publishing. Once published, the deployment of these projects is handled outside of #AzureDevOps.</p> <p>Despite the size of the code base, productivity isn’t terrible. The developers work together in unison to deliver features and enhancements into production many times per day. But there are inefficiencies within the design, process and implementation of the CI / CD pipeline that, once removed, would accelerate the productivity of our teams.</p> <p>Today is day 0. Today is where we will start this journey, and our current software development life cycle (SDLC) benchmarks are as follows:</p> <ul> <li>Feature Development takes ~ 55m to deploy to a testing environment.</li> <li>PR / Code Review takes ~ 55m to run automated build validation tasks.</li> <li>Deployment takes ~ 55m to build and create a production channel deployment.</li> </ul> <p>Yes - these times are suspiciously similar. We will cover that in a future post.</p> <p><br/></p> <hr/> <h3>The Series</h3> <p><br/></p> <div class="container"> <div class="row row-cols-2"> <div class="card-item col"> <a href="/blog/2023/faster-ci-node-caching/"> <div class="card hoverable"> <div class="row g-0"> <div class="col-md-12"> <div class="card-body"> <h3 class="card-title text-lowercase">node dependency caching</h3> <p class="card-text">Cache Node.JS dependencies between pipeline runs. </p> </div> </div> </div> </div> </a> </div> </div> </div> <p><br/></p>]]></content><author><name></name></author><category term="azure-devops"/><category term="azure-devops"/><category term="azure"/><category term="cicd"/><category term="performance"/><summary type="html"><![CDATA[A blog series documenting my learnings as I journey towards massively optimising #AzureDevOps Pipelines.]]></summary></entry></feed>